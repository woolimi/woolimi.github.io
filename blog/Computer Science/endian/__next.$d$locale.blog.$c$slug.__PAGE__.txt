1:"$Sreact.fragment"
2:I[26334,["1921","static/chunks/79812939-dd468ad34b0555ab.js","2969","static/chunks/8fdae66b-3313d3073a4d6626.js","9991","static/chunks/9991-ccaf069d2d1a3394.js","650","static/chunks/650-f48a6caa28b58c59.js","7285","static/chunks/7285-e0b078d0c178a272.js","2061","static/chunks/2061-28fac52e9cc6c1cf.js","1283","static/chunks/1283-41499aa8a4a2d40d.js","5441","static/chunks/5441-6139f8dec0b22e57.js","5784","static/chunks/app/%5Blocale%5D/blog/%5B...slug%5D/page-b33400911b20deaf.js"],"BlurFade"]
3:I[935,["1921","static/chunks/79812939-dd468ad34b0555ab.js","2969","static/chunks/8fdae66b-3313d3073a4d6626.js","9991","static/chunks/9991-ccaf069d2d1a3394.js","650","static/chunks/650-f48a6caa28b58c59.js","7285","static/chunks/7285-e0b078d0c178a272.js","2061","static/chunks/2061-28fac52e9cc6c1cf.js","1283","static/chunks/1283-41499aa8a4a2d40d.js","5441","static/chunks/5441-6139f8dec0b22e57.js","5784","static/chunks/app/%5Blocale%5D/blog/%5B...slug%5D/page-b33400911b20deaf.js"],"default"]
4:I[68708,["1921","static/chunks/79812939-dd468ad34b0555ab.js","2969","static/chunks/8fdae66b-3313d3073a4d6626.js","9991","static/chunks/9991-ccaf069d2d1a3394.js","650","static/chunks/650-f48a6caa28b58c59.js","7285","static/chunks/7285-e0b078d0c178a272.js","2061","static/chunks/2061-28fac52e9cc6c1cf.js","1283","static/chunks/1283-41499aa8a4a2d40d.js","5441","static/chunks/5441-6139f8dec0b22e57.js","5784","static/chunks/app/%5Blocale%5D/blog/%5B...slug%5D/page-b33400911b20deaf.js"],"MarkdownContent",1]
8:I[64725,[],"OutletBoundary"]
9:"$Sreact.suspense"
:HL["/_next/static/css/911e6a603adbdfb3.css","style"]
5:T1b96,
## 엔디안이란?

**엔디안**은 메모리에 저장된 **멀티바이트 데이터의 바이트 순서**(Byte Order)를 나타내는 개념이다. 같은 데이터를 저장할 때 바이트를 어떤 순서로 배치하느냐에 따라 해석이 달라진다.

## 엔디안이 적용되는 데이터 타입

### 적용되는 데이터 타입

엔디안은 **1바이트보다 큰 데이터 타입**에만 적용된다:

| 데이터 타입 | 크기                                | 엔디안 적용 여부 |
| ----------- | ----------------------------------- | ---------------- |
| `char`      | 1바이트                             | ❌ 적용 안 된다  |
| `short`     | 2바이트                             | ✅ 적용됨        |
| `int`       | 4바이트                             | ✅ 적용됨        |
| `long`      | 4바이트 (32비트) / 8바이트 (64비트) | ✅ 적용됨        |
| `long long` | 8바이트                             | ✅ 적용됨        |
| `float`     | 4바이트                             | ✅ 적용됨        |
| `double`    | 8바이트                             | ✅ 적용됨        |
| `pointer`   | 4바이트 (32비트) / 8바이트 (64비트) | ✅ 적용됨        |

### 핵심 원리

- **1바이트 데이터**: 엔디안 문제가 없다. 바이트가 하나뿐이므로 순서가 의미가 없다.
- **멀티바이트 데이터**: 2바이트 이상의 데이터는 바이트 순서에 따라 해석이 달라진다.

## 엔디안의 종류

### Big Endian (빅 엔디안)

**바이트를 낮은 주소부터 저장**하는 방식이다.

```
메모리 주소:  [0x1000] [0x1001] [0x1002] [0x1003]
데이터:      [  0x12] [  0x34] [  0x56] [  0x78]
            ↑ 여기서 시작
```

- **사람이 읽기 쉬운 순서**: 왼쪽에서 오른쪽으로 읽으면 자연스럽다.
- **사용 예시**: 네트워크 프로토콜(IP 주소 등), 일부 프로세서(ARM의 일부 모드, PowerPC 등)

### Little Endian (리틀 엔디안)

**바이트를 높은 주소부터 저장**하는 방식이다.

```
메모리 주소:  [0x1000] [0x1001] [0x1002] [0x1003]
데이터:      [  0x78] [  0x56] [  0x34] [  0x12]
                                       ↑ 여기서 시작
```

- **메모리 효율성**: 산술연산은 하위 바이트에서 시작하기 때문에 리틀 엔디안 방식은 cpu 연산에 유리하다.
- **사용 예시**: x86/x64 아키텍처, 대부분의 개인용 컴퓨터

## 뒤집는 단위와 범위

### 뒤집는 단위: **바이트(Byte) 단위**

엔디안은 **바이트 단위로 뒤집힌다**. 비트 단위가 아니다.

#### 예시: 0x12345678 (4바이트 정수)

**Big Endian:**

```
메모리 주소:  0x1000  0x1001  0x1002  0x1003
바이트 값:    0x12    0x34    0x56    0x78
```

**Little Endian:**

```
메모리 주소:  0x1000  0x1001  0x1002  0x1003
바이트 값:    0x78    0x56    0x34    0x12
```

각 바이트 내부의 비트 순서는 **변하지 않는다**. 바이트 단위로만 순서가 바뀐다.

### 뒤집는 범위: **전체 데이터 타입의 크기**

엔디안 변환은 **데이터 타입의 전체 크기 범위**에 적용된다.

#### 2바이트 데이터 (short)

```c
short value = 0x1234;  // 2바이트
```

**Big Endian:**

```
[0x12] [0x34]
```

**Little Endian:**

```
[0x34] [0x12]
```

#### 4바이트 데이터 (int)

```c
int value = 0x12345678;  // 4바이트
```

**Big Endian:**

```
[0x12] [0x34] [0x56] [0x78]
```

**Little Endian:**

```
[0x78] [0x56] [0x34] [0x12]
```

#### 8바이트 데이터 (long long)

```c
long long value = 0x1234567890ABCDEF;  // 8바이트
```

**Big Endian:**

```
[0x12] [0x34] [0x56] [0x78] [0x90] [0xAB] [0xCD] [0xEF]
```

**Little Endian:**

```
[0xEF] [0xCD] [0xAB] [0x90] [0x78] [0x56] [0x34] [0x12]
```

## 실제 예제

### C 코드로 확인하기

```c
#include <stdio.h>

int main() {
    int value = 0x12345678;
    unsigned char *bytes = (unsigned char *)&value;

    printf("Value: 0x%08X\n", value);
    printf("Memory layout:\n");
    for (int i = 0; i < sizeof(int); i++) {
        printf("  [%p]: 0x%02X\n", &bytes[i], bytes[i]);
    }

    return 0;
}
```

### 4바이트 int를 Little Endian으로 변환하는 toBytes 함수

```c
#include <stdio.h>
#include <stdint.h>

void toBytes(uint32_t value, unsigned char *bytes) {
    // Little Endian: 낮은 주소부터 LSB부터 저장
    bytes[0] = (value >> 0) & 0xFF;  // LSB (0x78)
    bytes[1] = (value >> 8) & 0xFF;  // 0x56
    bytes[2] = (value >> 16) & 0xFF; // 0x34
    bytes[3] = (value >> 24) & 0xFF; // MSB (0x12)
}

int main() {
    uint32_t value = 0x12345678;
    unsigned char bytes[4];

    toBytes(value, bytes);

    printf("Value: 0x%08X\n", value);
    printf("Little Endian bytes:\n");
    for (int i = 0; i < 4; i++) {
        printf("  bytes[%d] = 0x%02X\n", i, bytes[i]);
    }

    // 출력:
    // Value: 0x12345678
    // Little Endian bytes:
    //   bytes[0] = 0x78
    //   bytes[1] = 0x56
    //   bytes[2] = 0x34
    //   bytes[3] = 0x12

    return 0;
}
```

## 엔디안이 중요한 상황

### 1. 네트워크 통신

네트워크 프로토콜은 **Big Endian(Network Byte Order)**을 표준으로 사용한다. 서로 다른 엔디안을 가진 시스템 간 통신 시 변환이 필요하다.

```c
// 네트워크 바이트 순서로 변환
uint32_t host_value = 0x12345678;
uint32_t network_value = htonl(host_value);  // Host TO Network Long
```

### 2. 파일 포맷

바이너리 파일 포맷은 특정 엔디안을 가정한다. 예를 들어:

- **PNG**: Big Endian
- **GIF**: Little Endian
- **JPEG**: Big Endian

### 3. 프로세서 간 데이터 공유

서로 다른 엔디안을 가진 프로세서 간 데이터를 공유할 때 변환이 필요하다.

### 4. 디버깅

메모리 덤프를 읽을 때 엔디안을 고려해야 올바르게 해석할 수 있다.

## 요약

| 항목                 | 설명                                                                                     |
| -------------------- | ---------------------------------------------------------------------------------------- |
| **적용 데이터 타입** | 1바이트보다 큰 모든 멀티바이트 데이터 타입 (short, int, long, float, double, pointer 등) |
| **뒤집는 단위**      | **바이트(Byte) 단위** (비트 단위 아님)                                                   |
| **뒤집는 범위**      | **데이터 타입의 전체 크기** (2바이트면 2바이트 전체, 4바이트면 4바이트 전체)             |
| **핵심 원리**        | 각 바이트 내부의 비트 순서는 변하지 않고, 바이트들의 순서만 바뀜                         |

## 추가 참고사항

- **엔디안 중립 코드 작성**: 네트워크 통신이나 파일 I/O 시에는 항상 엔디안 변환 함수(`htonl`, `ntohl` 등)를 사용해야 한다.
- **현대 시스템**: 대부분의 개인용 컴퓨터는 Little Endian을 사용하지만, 네트워크 표준은 Big Endian이므로 변환이 필요하다.
0:{"buildId":"7wrLch1PHmN9S3I0q82uc","rsc":["$","$1","c",{"children":[["$","section",null,{"id":"blog","className":"mb-30","children":["$","$L2",null,{"delay":0.04,"duration":0.5,"blur":"4px","children":[["$","nav",null,{"aria-label":"breadcrumb","data-slot":"breadcrumb","className":"mb-6","children":["$","ol",null,{"data-slot":"breadcrumb-list","className":"text-muted-foreground flex flex-wrap items-center gap-1.5 text-sm break-words sm:gap-2.5","children":[["$","li","item-0",{"data-slot":"breadcrumb-item","className":"inline-flex items-center gap-1.5","children":["$","$L3",null,{"ref":null,"href":"/ko","localeCookie":{"name":"NEXT_LOCALE","sameSite":"lax"},"children":"Home","data-slot":"breadcrumb-link","className":"hover:text-foreground transition-colors"}]}],["$","li","separator-1",{"data-slot":"breadcrumb-separator","role":"presentation","aria-hidden":"true","className":"[&>svg]:size-3.5","children":["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-chevron-right","aria-hidden":"true","children":[["$","path","mthhwq",{"d":"m9 18 6-6-6-6"}],"$undefined"]}]}],["$","li","item-1",{"data-slot":"breadcrumb-item","className":"inline-flex items-center gap-1.5","children":["$","$L3",null,{"ref":null,"href":"/ko/blog","localeCookie":{"name":"NEXT_LOCALE","sameSite":"lax"},"children":"Blog","data-slot":"breadcrumb-link","className":"hover:text-foreground transition-colors"}]}],["$","li","separator-2",{"data-slot":"breadcrumb-separator","role":"presentation","aria-hidden":"true","className":"[&>svg]:size-3.5","children":["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-chevron-right","aria-hidden":"true","children":[["$","path","mthhwq",{"d":"m9 18 6-6-6-6"}],"$undefined"]}]}],["$","li","item-2",{"data-slot":"breadcrumb-item","className":"inline-flex items-center gap-1.5","children":["$","$L3",null,{"ref":null,"href":"/ko/blog/Computer Science","localeCookie":{"name":"NEXT_LOCALE","sameSite":"lax"},"children":"Computer Science","data-slot":"breadcrumb-link","className":"hover:text-foreground transition-colors"}]}],["$","li","separator-3",{"data-slot":"breadcrumb-separator","role":"presentation","aria-hidden":"true","className":"[&>svg]:size-3.5","children":["$","svg",null,{"xmlns":"http://www.w3.org/2000/svg","width":24,"height":24,"viewBox":"0 0 24 24","fill":"none","stroke":"currentColor","strokeWidth":2,"strokeLinecap":"round","strokeLinejoin":"round","className":"lucide lucide-chevron-right","aria-hidden":"true","children":[["$","path","mthhwq",{"d":"m9 18 6-6-6-6"}],"$undefined"]}]}],["$","li","item-3",{"data-slot":"breadcrumb-item","className":"inline-flex items-center gap-1.5","children":["$","span",null,{"data-slot":"breadcrumb-page","role":"link","aria-disabled":"true","aria-current":"page","className":"text-foreground font-normal","children":"엔디안"}]}]]}]}],["$","script",null,{"type":"application/ld+json","suppressHydrationWarning":true,"dangerouslySetInnerHTML":{"__html":"{\"@context\":\"https://schema.org\",\"@type\":\"BlogPosting\",\"headline\":\"엔디안\",\"description\":\"엔디안의 개념, 적용되는 데이터 타입, 바이트 순서 뒤집기 단위와 범위 정리\",\"image\":\"https://woolimi.github.io/og?title=엔디안\",\"url\":\"https://woolimi.github.io/blog/Computer Science/endian\",\"author\":{\"@type\":\"Person\",\"name\":\"박우림\"}}"}}],["$","h1",null,{"className":"text-3xl mb-4 md:mb-10 leading-none font-semibold tracking-tight sm:text-4xl sm:leading-none md:text-5xl md:leading-none lg:text-6xl lg:leading-none","children":"엔디안"}],["$","article",null,{"children":["$","$L4",null,{"children":"$5"}]}]]}]}],["$L6"],"$L7"]}],"loading":null,"isPartial":false}
6:["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/911e6a603adbdfb3.css","precedence":"next"}]
7:["$","$L8",null,{"children":["$","$9",null,{"name":"Next.MetadataOutlet","children":"$@a"}]}]
a:null
